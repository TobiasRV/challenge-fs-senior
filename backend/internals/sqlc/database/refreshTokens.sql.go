// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refreshTokens.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (id, userId, token, expires_at, created_at, revoked)
VALUES($1, $2, $3, $4, $5, $6)
`

type CreateRefreshTokenParams struct {
	ID        uuid.UUID
	Userid    uuid.UUID
	Token     string
	ExpiresAt time.Time
	CreatedAt time.Time
	Revoked   bool
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRefreshToken,
		arg.ID,
		arg.Userid,
		arg.Token,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.Revoked,
	)
	return err
}

const deleteRefreshTokensByUserId = `-- name: DeleteRefreshTokensByUserId :exec
DELETE FROM refresh_tokens
WHERE userId = $1
`

func (q *Queries) DeleteRefreshTokensByUserId(ctx context.Context, userid uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRefreshTokensByUserId, userid)
	return err
}

const getRefreshTokenByToken = `-- name: GetRefreshTokenByToken :one
SELECT refresh_tokens.id, refresh_tokens.userid, refresh_tokens.token, refresh_tokens.expires_at, refresh_tokens.created_at, refresh_tokens.revoked,
users.id AS userDataId,
users.created_at AS userDataCreatedAt,
users.updated_at AS userDataUpdatedAt,
users.username AS userDataUsername,
users.password AS userDataPassword,
users.email AS userDataEmail,
users.role AS userDataRole
FROM refresh_tokens
JOIN users ON refresh_tokens.userId = users.id
WHERE token = $1
LIMIT 1
`

type GetRefreshTokenByTokenRow struct {
	ID                uuid.UUID
	Userid            uuid.UUID
	Token             string
	ExpiresAt         time.Time
	CreatedAt         time.Time
	Revoked           bool
	Userdataid        uuid.UUID
	Userdatacreatedat time.Time
	Userdataupdatedat time.Time
	Userdatausername  string
	Userdatapassword  string
	Userdataemail     string
	Userdatarole      Userroles
}

func (q *Queries) GetRefreshTokenByToken(ctx context.Context, token string) (GetRefreshTokenByTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getRefreshTokenByToken, token)
	var i GetRefreshTokenByTokenRow
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Revoked,
		&i.Userdataid,
		&i.Userdatacreatedat,
		&i.Userdataupdatedat,
		&i.Userdatausername,
		&i.Userdatapassword,
		&i.Userdataemail,
		&i.Userdatarole,
	)
	return i, err
}

const updaterefreshToken = `-- name: UpdaterefreshToken :exec
UPDATE refresh_tokens
SET token = $1, expires_at = $2, created_at = $3, revoked = $4
WHERE id = $5
`

type UpdaterefreshTokenParams struct {
	Token     string
	ExpiresAt time.Time
	CreatedAt time.Time
	Revoked   bool
	ID        uuid.UUID
}

func (q *Queries) UpdaterefreshToken(ctx context.Context, arg UpdaterefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, updaterefreshToken,
		arg.Token,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.Revoked,
		arg.ID,
	)
	return err
}
